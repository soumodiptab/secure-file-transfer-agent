var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const transformer = require("../transformer");
const vscode = require("vscode-languageserver-protocol");
const common_1 = require("../utils/common");
const featureWorkers_1 = require("../utils/featureWorkers");
function register(context) {
    return (uri, range) => __awaiter(this, void 0, void 0, function* () {
        const document = context.getTextDocument(uri);
        if (!document)
            return;
        const offsetRange = {
            start: document.offsetAt(range.start),
            end: document.offsetAt(range.end),
        };
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, range, (_arg, map, file) => {
            /**
             * copy from ./codeActions.ts
             */
            var _a, _b;
            if (!file.capabilities.inlayHint)
                return [];
            let minStart;
            let maxEnd;
            for (const mapping of map.map.mappings) {
                const overlapRange = (0, common_1.getOverlapRange)(offsetRange.start, offsetRange.end, mapping.sourceRange[0], mapping.sourceRange[1]);
                if (overlapRange) {
                    const start = (_a = map.map.toGeneratedOffset(overlapRange.start)) === null || _a === void 0 ? void 0 : _a[0];
                    const end = (_b = map.map.toGeneratedOffset(overlapRange.end)) === null || _b === void 0 ? void 0 : _b[0];
                    if (start !== undefined && end !== undefined) {
                        minStart = minStart === undefined ? start : Math.min(start, minStart);
                        maxEnd = maxEnd === undefined ? end : Math.max(end, maxEnd);
                    }
                }
            }
            if (minStart !== undefined && maxEnd !== undefined) {
                return [vscode.Range.create(map.virtualFileDocument.positionAt(minStart), map.virtualFileDocument.positionAt(maxEnd))];
            }
            return [];
        }, (plugin, document, arg) => {
            var _a, _b;
            return (_b = (_a = plugin.inlayHints) === null || _a === void 0 ? void 0 : _a.on) === null || _b === void 0 ? void 0 : _b.call(_a, document, arg);
        }, (inlayHints, map) => inlayHints.map(_inlayHint => {
            var _a;
            if (!map)
                return _inlayHint;
            const position = map.toSourcePosition(_inlayHint.position);
            const edits = (_a = _inlayHint.textEdits) === null || _a === void 0 ? void 0 : _a.map(textEdit => transformer.asTextEdit(textEdit, range => map.toSourceRange(range), map.virtualFileDocument)).filter(shared.notEmpty);
            if (position) {
                return Object.assign(Object.assign({}, _inlayHint), { position,
                    edits });
            }
        }).filter(shared.notEmpty), arr => arr.flat());
    });
}
exports.register = register;
//# sourceMappingURL=inlayHints.js.map