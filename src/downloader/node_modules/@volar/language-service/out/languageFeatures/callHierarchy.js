var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const path_1 = require("path");
const dedupe = require("../utils/dedupe");
const featureWorkers_1 = require("../utils/featureWorkers");
function register(context) {
    return {
        doPrepare(uri, position) {
            return (0, featureWorkers_1.languageFeatureWorker)(context, uri, position, (position, map) => map.toGeneratedPositions(position, data => !!data.references), (plugin, document, position, map) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const items = yield ((_a = plugin.callHierarchy) === null || _a === void 0 ? void 0 : _a.prepare(document, position));
                return items === null || items === void 0 ? void 0 : items.map(item => {
                    return Object.assign(Object.assign({}, item), { data: {
                            uri,
                            originalItem: item,
                            pluginId: context.plugins.indexOf(plugin),
                            map: map ? {
                                embeddedDocumentUri: map.virtualFileDocument.uri,
                            } : undefined,
                        } });
                });
            }), (data, sourceMap) => !sourceMap ? data : data
                .map(item => { var _a; return (_a = transformCallHierarchyItem(item, [])) === null || _a === void 0 ? void 0 : _a[0]; })
                .filter(shared.notEmpty), arr => dedupe.withLocations(arr.flat()));
        },
        getIncomingCalls(item) {
            return __awaiter(this, void 0, void 0, function* () {
                const data = item.data;
                let incomingItems = [];
                if (data) {
                    const plugin = context.plugins[data.pluginId];
                    if (!plugin)
                        return incomingItems;
                    if (!plugin.callHierarchy)
                        return incomingItems;
                    const originalItem = data.originalItem;
                    if (data.map) {
                        if (context.documents.hasVirtualFileByUri(data.map.embeddedDocumentUri)) {
                            const _calls = yield plugin.callHierarchy.onIncomingCalls(originalItem);
                            for (const _call of _calls) {
                                const calls = transformCallHierarchyItem(_call.from, _call.fromRanges);
                                if (!calls)
                                    continue;
                                incomingItems.push({
                                    from: calls[0],
                                    fromRanges: calls[1],
                                });
                            }
                        }
                    }
                    else {
                        const _calls = yield plugin.callHierarchy.onIncomingCalls(item);
                        for (const _call of _calls) {
                            const calls = transformCallHierarchyItem(_call.from, _call.fromRanges);
                            if (!calls)
                                continue;
                            incomingItems.push({
                                from: calls[0],
                                fromRanges: calls[1],
                            });
                        }
                    }
                }
                return dedupe.withCallHierarchyIncomingCalls(incomingItems);
            });
        },
        getOutgoingCalls(item) {
            return __awaiter(this, void 0, void 0, function* () {
                const data = item.data;
                let items = [];
                if (data) {
                    const plugin = context.plugins[data.pluginId];
                    if (!plugin)
                        return items;
                    if (!plugin.callHierarchy)
                        return items;
                    const originalItem = data.originalItem;
                    if (data.map) {
                        if (context.documents.hasVirtualFileByUri(data.map.embeddedDocumentUri)) {
                            const _calls = yield plugin.callHierarchy.onOutgoingCalls(originalItem);
                            for (const call of _calls) {
                                const calls = transformCallHierarchyItem(call.to, call.fromRanges);
                                if (!calls)
                                    continue;
                                items.push({
                                    to: calls[0],
                                    fromRanges: calls[1],
                                });
                            }
                        }
                    }
                    else {
                        const _calls = yield plugin.callHierarchy.onOutgoingCalls(item);
                        for (const call of _calls) {
                            const calls = transformCallHierarchyItem(call.to, call.fromRanges);
                            if (!calls)
                                continue;
                            items.push({
                                to: calls[0],
                                fromRanges: calls[1],
                            });
                        }
                    }
                }
                return dedupe.withCallHierarchyOutgoingCalls(items);
            });
        },
    };
    function transformCallHierarchyItem(tsItem, tsRanges) {
        if (!context.documents.hasVirtualFileByUri(tsItem.uri))
            return [tsItem, tsRanges];
        for (const [_, map] of context.documents.getMapsByVirtualFileUri(tsItem.uri)) {
            let range = map.toSourceRange(tsItem.range);
            if (!range) {
                // TODO: <script> range
                range = {
                    start: map.sourceFileDocument.positionAt(0),
                    end: map.sourceFileDocument.positionAt(map.sourceFileDocument.getText().length),
                };
            }
            const selectionRange = map.toSourceRange(tsItem.selectionRange);
            if (!selectionRange)
                continue;
            const vueRanges = tsRanges.map(tsRange => map.toSourceRange(tsRange)).filter(shared.notEmpty);
            const vueItem = Object.assign(Object.assign({}, tsItem), { name: tsItem.name === path_1.posix.basename(shared.uriToFileName(map.virtualFileDocument.uri)) ? path_1.posix.basename(shared.uriToFileName(map.sourceFileDocument.uri)) : tsItem.name, uri: map.sourceFileDocument.uri, 
                // TS Bug: `range: range` not works
                range: {
                    start: range.start,
                    end: range.end,
                }, selectionRange: {
                    start: selectionRange.start,
                    end: selectionRange.end,
                } });
            selectionRange.end;
            return [vueItem, vueRanges];
        }
    }
}
exports.register = register;
//# sourceMappingURL=callHierarchy.js.map